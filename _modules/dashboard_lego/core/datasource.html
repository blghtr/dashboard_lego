

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dashboard_lego.core.datasource &mdash; Dashboard Lego 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Dashboard Lego
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Core Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Comprehensive Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/index.html">Comprehensive API Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/magics.html">IPython Magic Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to Dashboard Lego</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Dashboard Lego</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dashboard_lego.core.datasource</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dashboard_lego.core.datasource</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the base data source with stateless 2-stage pipeline.</span>

<span class="sd">:hierarchy: [Core | DataSources | DataSource]</span>
<span class="sd">:relates-to:</span>
<span class="sd"> - motivated_by: &quot;v0.15.0 Refactor: Stateless architecture with 2-stage pipeline + optional lambda functions&quot;</span>
<span class="sd"> - implements: &quot;interface: &#39;DataSource&#39; with stateless pipeline and lambda function support&quot;</span>
<span class="sd"> - uses: [&quot;library: &#39;diskcache&#39;&quot;, &quot;class: &#39;DataBuilder&#39;&quot;, &quot;class: &#39;DataFilter&#39;&quot;]</span>

<span class="sd">:contract:</span>
<span class="sd"> - pre: &quot;data_builder and data_filter provided OR build_fn/transform_fn for simple cases&quot;</span>
<span class="sd"> - post: &quot;get_processed_data(params) runs Build → Filter pipeline&quot;</span>
<span class="sd"> - invariant: &quot;NO stored data state, NO abstract methods, only cache&quot;</span>

<span class="sd">:complexity: 7</span>
<span class="sd">:decision_cache: &quot;2-stage pipeline (Build → Filter) for semantic clarity + lambda functions for simplicity&quot;</span>

<span class="sd">Example usage with lambda functions:</span>
<span class="sd">    &gt;&gt;&gt; # Simple datasource with lambda functions</span>
<span class="sd">    &gt;&gt;&gt; ds = DataSource(</span>
<span class="sd">    ...     build_fn=lambda params: pd.DataFrame({&#39;x&#39;: [1, 2, 3]}),</span>
<span class="sd">    ...     transform_fn=lambda df: df * 2</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; result = ds.get_processed_data()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # More complex with parameters</span>
<span class="sd">    &gt;&gt;&gt; ds = DataSource(</span>
<span class="sd">    ...     build_fn=lambda params: pd.read_csv(params.get(&#39;file&#39;, &#39;default.csv&#39;)),</span>
<span class="sd">    ...     transform_fn=lambda df: df.groupby(&#39;category&#39;).sum().reset_index()</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; result = ds.get_processed_data({&#39;file&#39;: &#39;sales.csv&#39;})</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">diskcache</span><span class="w"> </span><span class="kn">import</span> <span class="n">Cache</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">CacheError</span><span class="p">,</span> <span class="n">DataLoadError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.formatting</span><span class="w"> </span><span class="kn">import</span> <span class="n">NumpyEncoder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.logger</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_logger</span>


<div class="viewcode-block" id="DataSource">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DataSource</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base data source with stateless 2-stage pipeline.</span>

<span class="sd">    Pipeline stages (all via cache):</span>
<span class="sd">    1. Build (DataBuilder.build) - Load + Process</span>
<span class="sd">    2. Filter (DataFilter.filter) - Apply filters</span>

<span class="sd">    NO STORED STATE - data computed fresh each call via cache.</span>
<span class="sd">    NO ABSTRACT METHODS - fully concrete base class.</span>

<span class="sd">    :hierarchy: [Core | DataSources | DataSource]</span>
<span class="sd">    :relates-to:</span>
<span class="sd">     - motivated_by: &quot;v0.15.0: 2-stage pipeline for semantic clarity&quot;</span>
<span class="sd">     - implements: &quot;class: &#39;DataSource&#39; stateless&quot;</span>
<span class="sd">     - uses: [&quot;library: &#39;diskcache&#39;&quot;, &quot;class: &#39;DataBuilder&#39;&quot;, &quot;class: &#39;DataFilter&#39;&quot;]</span>

<span class="sd">    :rationale: &quot;2-stage pipeline (Build → Filter) simpler than 3-stage&quot;</span>
<span class="sd">    :contract:</span>
<span class="sd">     - pre: &quot;data_builder and data_filter provided&quot;</span>
<span class="sd">     - post: &quot;get_processed_data(params) returns filtered data via cache&quot;</span>
<span class="sd">     - invariant: &quot;No stored data attributes, no abstract methods&quot;</span>

<span class="sd">    :complexity: 7</span>
<span class="sd">    :decision_cache: &quot;Chose 2-stage over 3-stage for semantic clarity&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># LLM:METADATA</span>
    <span class="c1"># :hierarchy: [Core | DataSources | DataSource | CacheRegistry]</span>
    <span class="c1"># :relates-to:</span>
    <span class="c1">#  - motivated_by: &quot;Cache sharing prevents duplicate Stage1 builds when same builder reused across datasources created via with_transform_fn() [Contract-Fix-CacheSharing]&quot;</span>
    <span class="c1">#  - implements: &quot;Class-level cache registry for transparent cache reuse based on cache_dir matching&quot;</span>
    <span class="c1"># :contract:</span>
    <span class="c1">#  - invariant: &quot;Same cache_dir → same Cache instance; All cache_dir=None → single shared in-memory cache&quot;</span>
    <span class="c1"># :complexity: 2</span>
    <span class="c1"># :decision_cache: &quot;Class-level dict registry over singleton pattern: simpler, transparent, no global state pollution [decision-cache-registry-001]&quot;</span>
    <span class="c1"># LLM:END</span>
    <span class="n">_cache_registry</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Cache</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="DataSource.__init__">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_builder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_transformer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">param_classifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_ttl</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
        <span class="n">build_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize datasource with 2-stage pipeline.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Initialization]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: 2-stage pipeline configuration with optional lambda functions&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;__init__&#39;&quot;</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;data_builder, data_transformer, build_fn, transform_fn are optional&quot;</span>
<span class="sd">         - post: &quot;2-stage pipeline ready with handlers created from functions if provided&quot;</span>
<span class="sd">         - stages: &quot;Build → Transform&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            data_builder: DataBuilder for stage 1 (load + process). If None and build_fn provided, creates LambdaBuilder.</span>
<span class="sd">            data_transformer: DataTransformer for stage 2 (filtering/aggregation). If None and transform_fn provided, creates LambdaTransformer.</span>
<span class="sd">            param_classifier: Routes params: &#39;build&#39; or &#39;transform&#39;. Default: &#39;build__&#39; → &#39;build&#39;, &#39;transform__&#39; → &#39;transform&#39;.</span>
<span class="sd">            cache_dir: Directory for disk cache. If None, uses in-memory cache.</span>
<span class="sd">            cache_ttl: Time-to-live for cache entries in seconds.</span>
<span class="sd">            build_fn: Optional lambda function for simple data building: Dict[str, Any] → DataFrame.</span>
<span class="sd">                     If provided, creates LambdaBuilder automatically. Signature: lambda params: df</span>
<span class="sd">            transform_fn: Optional lambda function for simple data transformation: DataFrame → DataFrame.</span>
<span class="sd">                         If provided, creates LambdaTransformer automatically. Signature: lambda df: df</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_default_param_classifier</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="n">k</span>
            <span class="n">category</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">category</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;build&quot;</span>
            <span class="k">return</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">DataSource</span><span class="p">)</span>

        <span class="c1"># LLM:METADATA</span>
        <span class="c1"># :hierarchy: [Core | DataSources | DataSource | CacheInitialization]</span>
        <span class="c1"># :relates-to:</span>
        <span class="c1">#  - motivated_by: &quot;Cache sharing prevents duplicate Stage1 builds by reusing Cache objects for matching cache_dir [Contract-Fix-CacheSharing]&quot;</span>
        <span class="c1">#  - implements: &quot;Cache registry lookup and reuse logic in __init__&quot;</span>
        <span class="c1"># :contract:</span>
        <span class="c1">#  - pre: &quot;cache_dir is str or None, cache_ttl is int&quot;</span>
        <span class="c1">#  - post: &quot;self.cache is set to shared or new Cache instance&quot;</span>
        <span class="c1">#  - invariant: &quot;Same cache_dir → reuses existing Cache from registry; Different cache_dir → creates new Cache&quot;</span>
        <span class="c1"># :complexity: 3</span>
        <span class="c1"># LLM:END</span>

        <span class="c1"># Initialize cache with transparent sharing</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="n">cache_dir</span> <span class="k">if</span> <span class="n">cache_dir</span> <span class="k">else</span> <span class="s2">&quot;__in_memory__&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">:</span>
                <span class="c1"># Reuse existing cache for same cache_dir</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Reused cache | key=</span><span class="si">{</span><span class="n">cache_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create new cache and register it</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">Cache</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span> <span class="n">expire</span><span class="o">=</span><span class="n">cache_ttl</span><span class="p">)</span>
                <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Created new cache | key=</span><span class="si">{</span><span class="n">cache_key</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Cache failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CacheError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cache initialization failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Import here to avoid circular imports</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_builder</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataBuilder</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_transformer</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataTransformer</span>

        <span class="c1"># LLM:METADATA</span>
        <span class="c1"># :hierarchy: [Core | DataSources | DataSource | HandlerCreation]</span>
        <span class="c1"># :relates-to:</span>
        <span class="c1">#  - motivated_by: &quot;Create handlers from lambda functions if provided in constructor&quot;</span>
        <span class="c1">#  - implements: &quot;Lambda handler creation logic in __init__&quot;</span>
        <span class="c1"># :contract:</span>
        <span class="c1">#  - pre: &quot;build_fn and transform_fn are optional callables&quot;</span>
        <span class="c1">#  - post: &quot;data_builder and data_transformer are set (either provided or created from functions)&quot;</span>
        <span class="c1"># :complexity: 3</span>
        <span class="c1"># LLM:END</span>
        <span class="c1"># Create handlers from lambda functions if provided</span>
        <span class="n">final_data_builder</span> <span class="o">=</span> <span class="n">data_builder</span>
        <span class="n">final_data_transformer</span> <span class="o">=</span> <span class="n">data_transformer</span>

        <span class="k">if</span> <span class="n">build_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create LambdaBuilder from build_fn</span>
            <span class="k">class</span><span class="w"> </span><span class="nc">LambdaBuilder</span><span class="p">(</span><span class="n">DataBuilder</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Wraps a simple lambda function as a DataBuilder.</span>

<span class="sd">                :hierarchy: [Core | DataSources | LambdaBuilder]</span>
<span class="sd">                :relates-to:</span>
<span class="sd">                 - motivated_by: &quot;Wrap user lambda in DataBuilder interface&quot;</span>
<span class="sd">                 - implements: &quot;class: &#39;LambdaBuilder&#39;&quot;</span>

<span class="sd">                :contract:</span>
<span class="sd">                 - pre: &quot;Receives lambda: params → df&quot;</span>
<span class="sd">                 - post: &quot;Conforms to DataBuilder interface&quot;</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">):</span>
                    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Apply the wrapped lambda function.&quot;&quot;&quot;</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

            <span class="n">final_data_builder</span> <span class="o">=</span> <span class="n">LambdaBuilder</span><span class="p">(</span><span class="n">build_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[DataSource|Init] Created LambdaBuilder from build_fn&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create LambdaTransformer from transform_fn</span>
            <span class="k">class</span><span class="w"> </span><span class="nc">LambdaTransformer</span><span class="p">(</span><span class="n">DataTransformer</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Wraps a simple lambda function as a DataTransformer.</span>

<span class="sd">                :hierarchy: [Core | DataSources | LambdaTransformer]</span>
<span class="sd">                :relates-to:</span>
<span class="sd">                 - motivated_by: &quot;Wrap user lambda in DataTransformer interface&quot;</span>
<span class="sd">                 - implements: &quot;class: &#39;LambdaTransformer&#39;&quot;</span>

<span class="sd">                :contract:</span>
<span class="sd">                 - pre: &quot;Receives simple lambda: df → df&quot;</span>
<span class="sd">                 - post: &quot;Conforms to DataTransformer interface&quot;</span>
<span class="sd">                 - invariant: &quot;Ignores params (block transforms don&#39;t need them)&quot;</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">):</span>
                    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
                <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">                    </span><span class="sd">&quot;&quot;&quot;Apply the wrapped lambda function.&quot;&quot;&quot;</span>
                    <span class="c1"># Block-specific transforms don&#39;t use params</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">final_data_transformer</span> <span class="o">=</span> <span class="n">LambdaTransformer</span><span class="p">(</span><span class="n">transform_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;[DataSource|Init] Created LambdaTransformer from transform_fn&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize 2-stage pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span> <span class="o">=</span> <span class="n">final_data_builder</span> <span class="ow">or</span> <span class="n">DataBuilder</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span> <span class="o">=</span> <span class="n">final_data_transformer</span> <span class="ow">or</span> <span class="n">DataTransformer</span><span class="p">(</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">param_classifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param_classifier</span> <span class="o">=</span> <span class="n">_default_param_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span> <span class="o">=</span> <span class="n">param_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>  <span class="c1"># Store original cache_dir for cloning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span> <span class="o">=</span> <span class="n">cache_ttl</span>

        <span class="c1"># NO stored state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] 2-stage pipeline ready | &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;builder=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> | &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;transformer=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_cache_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create cache key for specific pipeline stage.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Caching]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;Stage-specific cache keys INCLUDING handler instance&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;_get_cache_key&#39;&quot;</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;stage is valid string, params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns stable cache key unique to stage + params + handler&quot;</span>
<span class="sd">         - invariant: &quot;Different builders/transformers get different cache keys; Same cache_dir → shared Cache object&quot;</span>

<span class="sd">        :decision_cache: &quot;Use hash(type(handler)) for classes, id() for lambdas&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            stage: Pipeline stage (&#39;built&#39;, &#39;filtered&#39;)</span>
<span class="sd">            params: Parameters relevant to this stage</span>

<span class="sd">        Returns:</span>
<span class="sd">            Stable cache key string including handler identity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get handler-specific suffix</span>
        <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;built&quot;</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span>
        <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;filtered&quot;</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">handler</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Hash handler type (stable for classes, unique for lambda instances)</span>
        <span class="n">handler_suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">handler</span><span class="p">:</span>
            <span class="c1"># For ChainedTransformer or LambdaTransformer: use id() since each instance is unique</span>
            <span class="c1"># For regular classes: use hash(type) for stability</span>
            <span class="n">handler_type_name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="n">handler_type_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;LambdaTransformer&quot;</span><span class="p">,</span> <span class="s2">&quot;ChainedTransformer&quot;</span><span class="p">):</span>
                <span class="n">handler_suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">handler_suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="nb">hash</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">handler</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">handler_suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Build cache key</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">_default</span><span class="si">{</span><span class="n">handler_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">params_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">NumpyEncoder</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">params_json</span><span class="si">}{</span><span class="n">handler_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get built data from cache or build fresh.</span>

<span class="sd">        Stage 1: Build (load + process).</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Stage1]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns complete built DataFrame&quot;</span>
<span class="sd">         - cache_key: &quot;Based on build params only&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Build parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Complete built DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage1|Build] No params | params=</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cache_key</span><span class="p">(</span><span class="s2">&quot;built&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Stage1|Build] Cache HIT&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[Stage1|Build] Cache MISS | building&quot;</span><span class="p">)</span>

        <span class="c1"># Call DataBuilder.build() - handles load + process</span>
        <span class="n">built_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DataBuilder.build must return DataFrame, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">built_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">built_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage1|Build] Complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">built_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">built_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">built_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get filtered data from cache or filter fresh.</span>

<span class="sd">        Stage 2: Filter.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Stage2]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;built_data is DataFrame, params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns filtered DataFrame&quot;</span>
<span class="sd">         - cache_key: &quot;Based on filter params only&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            built_data: Built DataFrame from stage 1</span>
<span class="sd">            params: Filter parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">built_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">built_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[Stage2|Transform] No built_data | built_data=</span><span class="si">{</span><span class="n">built_data</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">built_data</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cache_key</span><span class="p">(</span><span class="s2">&quot;filtered&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Stage2|Filter] Cache HIT&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[Stage2|Transform] Cache MISS | transforming&quot;</span><span class="p">)</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DataTransformer.transform must return DataFrame, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage2|Transform] Complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered_data</span>

<div class="viewcode-block" id="DataSource.with_builder">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_builder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">builder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new datasource with replaced builder.</span>

<span class="sd">        Immutable pattern for flexible data pipeline composition.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithBuilder]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;builder is DataBuilder instance&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource (does NOT modify self)&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            builder: DataBuilder instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource with specified builder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="n">builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>  <span class="c1"># Use original cache_dir for cache sharing</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_builder_fn">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_builder_fn">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_builder_fn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">build_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new datasource instance with a lambda-based builder.</span>

<span class="sd">        Convenience factory for simple build logic without creating DataBuilder class.</span>
<span class="sd">        Symmetric to with_transform_fn() for consistency.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithBuilderFn]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: Symmetric API with with_transform_fn()&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;with_builder_fn&#39;&quot;</span>
<span class="sd">         - uses: [&quot;class: &#39;DataBuilder&#39;&quot;]</span>

<span class="sd">        :rationale: &quot;Lambda-based builder for simple cases, avoiding class boilerplate&quot;</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;build_fn is callable: Dict[str, Any] → DataFrame&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource with lambda builder&quot;</span>
<span class="sd">         - invariant: &quot;Original datasource unchanged (immutable)&quot;</span>

<span class="sd">        :complexity: 2</span>
<span class="sd">        :decision_cache: &quot;Symmetric with_builder_fn/with_transform_fn API for consistency&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            build_fn: Function that builds DataFrame from params.</span>
<span class="sd">                     Signature: lambda params: df</span>
<span class="sd">                     Examples:</span>
<span class="sd">                     - lambda p: pd.read_csv(p[&#39;file_path&#39;])</span>
<span class="sd">                     - lambda p: generate_sample_data(n=p.get(&#39;rows&#39;, 100))</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource instance with lambda builder.</span>
<span class="sd">            Original datasource is unchanged.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Create datasource with lambda builder</span>
<span class="sd">            &gt;&gt;&gt; ds = DataSource().with_builder_fn(</span>
<span class="sd">            ...     lambda params: pd.read_csv(&#39;data.csv&#39;)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Or with params</span>
<span class="sd">            &gt;&gt;&gt; ds = DataSource().with_builder_fn(</span>
<span class="sd">            ...     lambda params: pd.read_csv(params.get(&#39;file&#39;, &#39;default.csv&#39;))</span>
<span class="sd">            ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_builder</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataBuilder</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[DataSource|WithBuilderFn] Creating datasource with lambda builder&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Wrap lambda in DataBuilder</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">LambdaBuilder</span><span class="p">(</span><span class="n">DataBuilder</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Wraps a simple lambda function as a DataBuilder.</span>

<span class="sd">            :hierarchy: [Core | DataSources | LambdaBuilder]</span>
<span class="sd">            :relates-to:</span>
<span class="sd">             - motivated_by: &quot;Wrap user lambda in DataBuilder interface&quot;</span>
<span class="sd">             - implements: &quot;class: &#39;LambdaBuilder&#39;&quot;</span>

<span class="sd">            :contract:</span>
<span class="sd">             - pre: &quot;Receives lambda: params → df&quot;</span>
<span class="sd">             - post: &quot;Conforms to DataBuilder interface&quot;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">):</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Apply the wrapped lambda function.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

        <span class="n">lambda_builder</span> <span class="o">=</span> <span class="n">LambdaBuilder</span><span class="p">(</span><span class="n">build_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[DataSource|WithBuilderFn] Created lambda builder&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="n">lambda_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>  <span class="c1"># Use original cache_dir for cache sharing</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_builder</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_transformer">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_transformer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new datasource with replaced transformer.</span>

<span class="sd">        Immutable pattern for flexible data pipeline composition.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithTransformer]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;transformer is DataTransformer instance&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource (does NOT modify self)&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            transformer: DataTransformer instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource with specified transformer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="n">transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>  <span class="c1"># Use original cache_dir for cache sharing</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_transformer</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_transform_fn">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_transform_fn">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_transform_fn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">transform_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new datasource instance with an additional transformation step</span>
<span class="sd">        chained AFTER the main data transformer.</span>

<span class="sd">        Factory method for creating specialized datasources with block-specific</span>
<span class="sd">        transformations. The new transformer is chained after the existing one,</span>
<span class="sd">        preserving the global filter → block transform order.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithTransform]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: Block-specific data transformations&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;with_transform_fn&#39;&quot;</span>
<span class="sd">         - uses: [&quot;class: &#39;ChainedTransformer&#39;&quot;]</span>

<span class="sd">        :rationale: &quot;Immutable pattern creates specialized clone without modifying original&quot;</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;transform_fn is callable: DataFrame → DataFrame&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource with chained transformer&quot;</span>
<span class="sd">         - invariant: &quot;Original datasource unchanged (immutable)&quot;</span>
<span class="sd">         - cache: &quot;New datasource has independent cache keys&quot;</span>

<span class="sd">        :complexity: 4</span>
<span class="sd">        :decision_cache: &quot;Use ChainedTransformer for global filter → block transform pipeline&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            transform_fn: Function that transforms a DataFrame.</span>
<span class="sd">                         Signature: lambda df: df (no params needed)</span>
<span class="sd">                         Examples:</span>
<span class="sd">                         - lambda df: df.groupby(&#39;category&#39;).sum()</span>
<span class="sd">                         - lambda df: df.pivot_table(...)</span>
<span class="sd">                         - lambda df: df.query(&quot;price &gt; 100&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource instance with chained transformer.</span>
<span class="sd">            Original datasource is unchanged.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Original datasource with global filter</span>
<span class="sd">            &gt;&gt;&gt; main_ds = DataSource(</span>
<span class="sd">            ...     data_builder=CSVBuilder(&quot;sales.csv&quot;),</span>
<span class="sd">            ...     data_transformer=CategoryFilter()  # Global filter</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create specialized datasource for aggregation</span>
<span class="sd">            &gt;&gt;&gt; agg_ds = main_ds.with_transform_fn(</span>
<span class="sd">            ...     lambda df: df.groupby(&#39;category&#39;)[&#39;sales&#39;].sum().reset_index()</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Original datasource unchanged, agg_ds has chained transformer</span>
<span class="sd">            &gt;&gt;&gt; data = agg_ds.get_processed_data({&#39;category&#39;: &#39;Electronics&#39;})</span>
<span class="sd">            &gt;&gt;&gt; # Flow: Build → CategoryFilter(category=&#39;Electronics&#39;) → GroupBy Aggregation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_transformer</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
            <span class="n">ChainedTransformer</span><span class="p">,</span>
            <span class="n">DataTransformer</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[DataSource|WithTransform] Creating specialized datasource clone&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 1. Create a new transformer from the provided function</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">LambdaTransformer</span><span class="p">(</span><span class="n">DataTransformer</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Wraps a simple lambda function as a DataTransformer.</span>

<span class="sd">            :hierarchy: [Core | DataSources | LambdaTransformer]</span>
<span class="sd">            :relates-to:</span>
<span class="sd">             - motivated_by: &quot;Wrap user lambda in DataTransformer interface&quot;</span>
<span class="sd">             - implements: &quot;class: &#39;LambdaTransformer&#39;&quot;</span>

<span class="sd">            :contract:</span>
<span class="sd">             - pre: &quot;Receives simple lambda: df → df&quot;</span>
<span class="sd">             - post: &quot;Conforms to DataTransformer interface&quot;</span>
<span class="sd">             - invariant: &quot;Ignores params (block transforms don&#39;t need them)&quot;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Apply the wrapped lambda function.&quot;&quot;&quot;</span>
                <span class="c1"># Block-specific transforms don&#39;t use params</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">block_specific_transformer</span> <span class="o">=</span> <span class="n">LambdaTransformer</span><span class="p">(</span><span class="n">transform_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="c1"># 2. Chain it with the existing global transformer</span>
        <span class="n">chained_transformer</span> <span class="o">=</span> <span class="n">ChainedTransformer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>  <span class="c1"># Global filter (first)</span>
            <span class="n">block_specific_transformer</span><span class="p">,</span>  <span class="c1"># Block transform (second)</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DataSource|WithTransform] Chained: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> → LambdaTransformer&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 3. Return a new datasource instance (clone) with the new chained transformer</span>
        <span class="c1"># Use stored cache_dir to ensure cache registry key matches parent</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="n">chained_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>  <span class="c1"># Use original cache_dir for cache sharing</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_transformer</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.get_processed_data">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.get_processed_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_processed_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run 2-stage pipeline and return filtered data.</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;params is dict or None&quot;</span>
<span class="sd">         - post: &quot;Returns filtered DataFrame&quot;</span>
<span class="sd">         - stages: &quot;Build → Filter (2 stages)&quot;</span>
<span class="sd">         - invariant: &quot;Stateless (no stored data)&quot;</span>

<span class="sd">        :complexity: 6</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Parameters for build + filter</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered DataFrame from 2-stage pipeline</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[get_processed_data] Called | params=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Classify params</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.processing_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataProcessingContext</span>

            <span class="n">context</span> <span class="o">=</span> <span class="n">DataProcessingContext</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">)</span>

            <span class="c1"># Stage 1: Build (load + process)</span>
            <span class="n">built_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_build</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span><span class="p">)</span>

            <span class="c1"># Stage 2: Filter</span>
            <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_transform</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">filtering_params</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[get_processed_data] Pipeline complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[get_processed_data] Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Dashboard Lego Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>