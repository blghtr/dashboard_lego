

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dashboard_lego.core.datasource &mdash; Dashboard Lego 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Dashboard Lego
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../concepts.html">Core Concepts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Comprehensive Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/index.html">Comprehensive API Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/magics.html">IPython Magic Commands</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing to Dashboard Lego</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Dashboard Lego</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dashboard_lego.core.datasource</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dashboard_lego.core.datasource</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines the base data source with stateless 2-stage pipeline.</span>

<span class="sd">:hierarchy: [Core | DataSources | DataSource]</span>
<span class="sd">:relates-to:</span>
<span class="sd"> - motivated_by: &quot;v0.15.0 Refactor: Stateless architecture with 2-stage pipeline + optional lambda functions&quot;</span>
<span class="sd"> - implements: &quot;interface: &#39;DataSource&#39; with stateless pipeline and lambda function support&quot;</span>
<span class="sd"> - uses: [&quot;library: &#39;diskcache&#39;&quot;, &quot;class: &#39;DataBuilder&#39;&quot;, &quot;class: &#39;DataFilter&#39;&quot;]</span>

<span class="sd">:contract:</span>
<span class="sd"> - pre: &quot;data_builder and data_filter provided OR build_fn/transform_fn for simple cases&quot;</span>
<span class="sd"> - post: &quot;get_processed_data(params) runs Build → Filter pipeline&quot;</span>
<span class="sd"> - invariant: &quot;NO stored data state, NO abstract methods, only cache&quot;</span>

<span class="sd">:complexity: 7</span>
<span class="sd">:decision_cache: &quot;2-stage pipeline (Build → Filter) for semantic clarity + lambda functions for simplicity&quot;</span>

<span class="sd">Example usage with lambda functions:</span>
<span class="sd">    &gt;&gt;&gt; # Simple datasource with lambda functions</span>
<span class="sd">    &gt;&gt;&gt; ds = DataSource(</span>
<span class="sd">    ...     build_fn=lambda params: pd.DataFrame({&#39;x&#39;: [1, 2, 3]}),</span>
<span class="sd">    ...     transform_fn=lambda df: df * 2</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; result = ds.get_processed_data()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # More complex with parameters</span>
<span class="sd">    &gt;&gt;&gt; ds = DataSource(</span>
<span class="sd">    ...     build_fn=lambda params: pd.read_csv(params.get(&#39;file&#39;, &#39;default.csv&#39;)),</span>
<span class="sd">    ...     transform_fn=lambda df: df.groupby(&#39;category&#39;).sum().reset_index()</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; result = ds.get_processed_data({&#39;file&#39;: &#39;sales.csv&#39;})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # With cache prewarming</span>
<span class="sd">    &gt;&gt;&gt; ds = DataSource(</span>
<span class="sd">    ...     build_fn=lambda params: pd.read_csv(params.get(&#39;file&#39;, &#39;default.csv&#39;)),</span>
<span class="sd">    ...     transform_fn=lambda df: df.groupby(&#39;category&#39;).sum().reset_index(),</span>
<span class="sd">    ...     cache_prewarm_params=[</span>
<span class="sd">    ...         {&#39;file&#39;: &#39;sales.csv&#39;, &#39;category&#39;: &#39;Electronics&#39;},</span>
<span class="sd">    ...         {&#39;file&#39;: &#39;sales.csv&#39;, &#39;category&#39;: &#39;Home&#39;}</span>
<span class="sd">    ...     ]</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; # Cache is now prewarmed for these parameter combinations</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pandas.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">hash_pandas_object</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AsyncSyncMismatchError</span><span class="p">,</span>
    <span class="n">CacheError</span><span class="p">,</span>
    <span class="n">DataLoadError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.lambda_handlers</span><span class="w"> </span><span class="kn">import</span> <span class="n">LambdaBuilder</span><span class="p">,</span> <span class="n">LambdaTransformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.formatting</span><span class="w"> </span><span class="kn">import</span> <span class="n">NumpyEncoder</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.hashing</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_stable_handler_id</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.utils.logger</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_logger</span>


<div class="viewcode-block" id="DataSource">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DataSource</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base data source with stateless 2-stage pipeline.</span>

<span class="sd">    Pipeline stages (all via cache):</span>
<span class="sd">    1. Build (DataBuilder.build) - Load + Process</span>
<span class="sd">    2. Filter (DataFilter.filter) - Apply filters</span>

<span class="sd">    NO STORED STATE - data computed fresh each call via cache.</span>
<span class="sd">    NO ABSTRACT METHODS - fully concrete base class.</span>

<span class="sd">    :hierarchy: [Core | DataSources | DataSource]</span>
<span class="sd">    :relates-to:</span>
<span class="sd">     - motivated_by: &quot;v0.15.0: 2-stage pipeline for semantic clarity&quot;</span>
<span class="sd">     - implements: &quot;class: &#39;DataSource&#39; stateless&quot;</span>
<span class="sd">     - uses: [&quot;library: &#39;diskcache&#39;&quot;, &quot;class: &#39;DataBuilder&#39;&quot;, &quot;class: &#39;DataFilter&#39;&quot;]</span>

<span class="sd">    :rationale: &quot;2-stage pipeline (Build → Filter) simpler than 3-stage&quot;</span>
<span class="sd">    :contract:</span>
<span class="sd">     - pre: &quot;data_builder and data_filter provided&quot;</span>
<span class="sd">     - post: &quot;get_processed_data(params) returns filtered data via cache&quot;</span>
<span class="sd">     - invariant: &quot;No stored data attributes, no abstract methods&quot;</span>

<span class="sd">    :complexity: 7</span>
<span class="sd">    :decision_cache: &quot;Chose 2-stage over 3-stage for semantic clarity&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># LLM:METADATA</span>
    <span class="c1"># :hierarchy: [Core | DataSources | DataSource | CacheRegistry]</span>
    <span class="c1"># :relates-to:</span>
    <span class="c1">#  - motivated_by: &quot;Cache sharing prevents duplicate Stage1 builds when same builder reused across datasources created via with_transform_fn() [Contract-Fix-CacheSharing]&quot;</span>
    <span class="c1">#  - implements: &quot;Class-level cache registry for transparent cache reuse based on backend config matching&quot;</span>
    <span class="c1"># :contract:</span>
    <span class="c1">#  - invariant: &quot;Same backend config → same backend instance; All cache_backend=None → single shared disk cache&quot;</span>
    <span class="c1"># :complexity: 2</span>
    <span class="c1"># :decision_cache: &quot;Class-level dict registry over singleton pattern: simpler, transparent, no global state pollution [decision-cache-registry-001]&quot;</span>
    <span class="c1"># LLM:END</span>
    <span class="n">_cache_registry</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="DataSource.__init__">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_builder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_transformer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">param_classifier</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_ttl</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
        <span class="n">cache_backend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">build_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache_prewarm_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize datasource with 2-stage pipeline.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Initialization]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: 2-stage pipeline configuration with optional lambda functions&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;__init__&#39;&quot;</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;df, build_fn, and data_builder are optional (if none provided, uses default DataBuilder)&quot;</span>
<span class="sd">         - post: &quot;2-stage pipeline ready with handlers created from df/build_fn/builder if provided, or default DataBuilder&quot;</span>
<span class="sd">         - stages: &quot;Build → Transform&quot;</span>
<span class="sd">         - priority: &quot;df → build_fn → data_builder → default DataBuilder (first provided wins)&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            data_builder: DataBuilder for stage 1 (load + process). If None and build_fn or df provided, creates appropriate builder.</span>
<span class="sd">            data_transformer: DataTransformer for stage 2 (filtering/aggregation). If None and transform_fn provided, creates LambdaTransformer.</span>
<span class="sd">            param_classifier: Routes params: &#39;build&#39; or &#39;transform&#39;. Default: &#39;build__&#39; → &#39;build&#39;, &#39;transform__&#39; → &#39;transform&#39;.</span>
<span class="sd">            cache_dir: Directory for disk cache. If None, uses in-memory cache. Ignored if cache_backend is provided.</span>
<span class="sd">            cache_ttl: Time-to-live for cache entries in seconds.</span>
<span class="sd">            cache_backend: Cache backend to use. Can be:</span>
<span class="sd">                          - &#39;disk&#39; or None: DiskCacheBackend (default, uses cache_dir)</span>
<span class="sd">                          - &#39;redis&#39;: RedisCacheBackend (localhost:6379)</span>
<span class="sd">                          - &#39;memory&#39;: InMemoryCacheBackend</span>
<span class="sd">                          - CacheBackend instance: Custom backend</span>
<span class="sd">            build_fn: Optional lambda function for simple data building: Dict[str, Any] → DataFrame.</span>
<span class="sd">                     If provided, creates LambdaBuilder automatically. Signature: lambda params: df</span>
<span class="sd">            transform_fn: Optional lambda function for simple data transformation: DataFrame → DataFrame.</span>
<span class="sd">                         If provided, creates LambdaTransformer automatically. Signature: lambda df: df</span>
<span class="sd">            cache_prewarm_params: Optional list of parameter dictionaries to prewarm cache during initialization.</span>
<span class="sd">                                 Each dict will be processed through the 2-stage pipeline to populate cache.</span>
<span class="sd">            df: Optional pandas DataFrame. If provided, automatically creates DfHandler as builder.</span>
<span class="sd">                If none of df/build_fn/data_builder provided, uses default DataBuilder (returns empty DataFrame).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_default_param_classifier</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="n">k</span>
            <span class="n">category</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">category</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="s2">&quot;transform&quot;</span><span class="p">):</span>
                <span class="n">category</span> <span class="o">=</span> <span class="s2">&quot;build&quot;</span>
            <span class="k">return</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">DataSource</span><span class="p">)</span>

        <span class="c1"># LLM:METADATA</span>
        <span class="c1"># :hierarchy: [Core | DataSources | DataSource | CacheInitialization]</span>
        <span class="c1"># :relates-to:</span>
        <span class="c1">#  - motivated_by: &quot;Contract 2: Support multiple cache backends (disk/Redis/memory)&quot;</span>
        <span class="c1">#  - implements: &quot;Cache backend initialization with pluggable backends&quot;</span>
        <span class="c1"># :contract:</span>
        <span class="c1">#  - pre: &quot;cache_backend is str or CacheBackend instance or None&quot;</span>
        <span class="c1">#  - post: &quot;self.cache is set to appropriate backend instance&quot;</span>
        <span class="c1">#  - invariant: &quot;Same backend config → reuses existing backend from registry&quot;</span>
        <span class="c1"># :complexity: 5</span>
        <span class="c1"># LLM:END</span>

        <span class="c1"># Initialize cache backend</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.cache</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
                <span class="n">DiskCacheBackend</span><span class="p">,</span>
                <span class="n">InMemoryCacheBackend</span><span class="p">,</span>
                <span class="n">RedisCacheBackend</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Cache backend module not found: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">CacheError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cache backend module not found: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Determine backend type and create instance</span>
        <span class="k">if</span> <span class="n">cache_backend</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cache_backend</span> <span class="o">==</span> <span class="s2">&quot;disk&quot;</span><span class="p">:</span>
            <span class="c1"># Default: disk cache</span>
            <span class="n">backend_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;disk:</span><span class="si">{</span><span class="n">cache_dir</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">cache_dir</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;__in_memory__&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">backend_key</span> <span class="ow">in</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Reused cache | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">DiskCacheBackend</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">cache_dir</span><span class="p">,</span> <span class="n">expire</span><span class="o">=</span><span class="n">cache_ttl</span><span class="p">)</span>
                <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Created DiskCacheBackend | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">cache_backend</span> <span class="o">==</span> <span class="s2">&quot;redis&quot;</span><span class="p">:</span>
            <span class="c1"># Redis cache (default localhost)</span>
            <span class="n">backend_key</span> <span class="o">=</span> <span class="s2">&quot;redis:localhost:6379:0&quot;</span>
            <span class="k">if</span> <span class="n">backend_key</span> <span class="ow">in</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Reused cache | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">RedisCacheBackend</span><span class="p">(</span><span class="n">expire</span><span class="o">=</span><span class="n">cache_ttl</span><span class="p">)</span>
                    <span class="c1"># Ping to validate connection</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="s2">&quot;_redis&quot;</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">_redis</span><span class="o">.</span><span class="n">ping</span><span class="p">()</span>
                    <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Created RedisCacheBackend | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Redis backend initialization failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">CacheError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Redis connection failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">elif</span> <span class="n">cache_backend</span> <span class="o">==</span> <span class="s2">&quot;memory&quot;</span><span class="p">:</span>
            <span class="c1"># In-memory cache</span>
            <span class="n">backend_key</span> <span class="o">=</span> <span class="s2">&quot;memory:__shared__&quot;</span>
            <span class="k">if</span> <span class="n">backend_key</span> <span class="ow">in</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Reused cache | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">InMemoryCacheBackend</span><span class="p">(</span><span class="n">expire</span><span class="o">=</span><span class="n">cache_ttl</span><span class="p">)</span>
                <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Created InMemoryCacheBackend | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Custom backend instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache_backend</span>
            <span class="n">backend_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;custom:</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="n">cache_backend</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">DataSource</span><span class="o">.</span><span class="n">_cache_registry</span><span class="p">[</span><span class="n">backend_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] Using custom backend | key=</span><span class="si">{</span><span class="n">backend_key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Store backend config for cloning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_backend</span> <span class="o">=</span> <span class="n">cache_backend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span> <span class="o">=</span> <span class="n">cache_ttl</span>

        <span class="c1"># Import here to avoid circular imports</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_builder</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataBuilder</span><span class="p">,</span> <span class="n">DfHandler</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_transformer</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFilter</span>

        <span class="c1"># LLM:METADATA</span>
        <span class="c1"># :hierarchy: [Core | DataSources | DataSource | HandlerCreation]</span>
        <span class="c1"># :relates-to:</span>
        <span class="c1">#  - motivated_by: &quot;Create handlers from DataFrame, lambda functions, or use provided builder&quot;</span>
        <span class="c1">#  - implements: &quot;Handler creation logic in __init__ with priority: df → build_fn → data_builder → default&quot;</span>
        <span class="c1"># :contract:</span>
        <span class="c1">#  - pre: &quot;df, build_fn, and data_builder are optional (if none provided, uses default DataBuilder)&quot;</span>
        <span class="c1">#  - post: &quot;data_builder and data_transformer are set (either provided or created or default)&quot;</span>
        <span class="c1"># :complexity: 3</span>
        <span class="c1"># LLM:END</span>
        <span class="c1"># Create handlers with priority: df → build_fn → data_builder → default DataBuilder</span>
        <span class="n">final_data_builder</span> <span class="o">=</span> <span class="n">data_builder</span>
        <span class="n">final_data_transformer</span> <span class="o">=</span> <span class="n">data_transformer</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create DfHandler from DataFrame (highest priority)</span>
            <span class="k">if</span> <span class="n">data_builder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;[DataSource|Init] Both &#39;df&#39; and &#39;data_builder&#39; provided, using &#39;df&#39; (DfHandler)&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">build_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;[DataSource|Init] Both &#39;df&#39; and &#39;build_fn&#39; provided, using &#39;df&#39; (DfHandler)&quot;</span>
                <span class="p">)</span>
            <span class="n">final_data_builder</span> <span class="o">=</span> <span class="n">DfHandler</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[DataSource|Init] Created DfHandler from df&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">build_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create LambdaBuilder from build_fn (second priority)</span>
            <span class="k">if</span> <span class="n">data_builder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;[DataSource|Init] Both &#39;build_fn&#39; and &#39;data_builder&#39; provided, using &#39;build_fn&#39; (LambdaBuilder)&quot;</span>
                <span class="p">)</span>
            <span class="n">final_data_builder</span> <span class="o">=</span> <span class="n">LambdaBuilder</span><span class="p">(</span><span class="n">build_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[DataSource|Init] Created LambdaBuilder from build_fn&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create LambdaTransformer from transform_fn (imported from lambda_handlers)</span>
            <span class="n">final_data_transformer</span> <span class="o">=</span> <span class="n">LambdaTransformer</span><span class="p">(</span><span class="n">transform_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;[DataSource|Init] Created LambdaTransformer from transform_fn&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize 2-stage pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span> <span class="o">=</span> <span class="n">final_data_builder</span> <span class="ow">or</span> <span class="n">DataBuilder</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="c1"># Default to DataFilter instead of DataTransformer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span> <span class="o">=</span> <span class="n">final_data_transformer</span> <span class="ow">or</span> <span class="n">DataFilter</span><span class="p">(</span><span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">param_classifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param_classifier</span> <span class="o">=</span> <span class="n">_default_param_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span> <span class="o">=</span> <span class="n">param_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span> <span class="o">=</span> <span class="n">cache_dir</span>  <span class="c1"># Store original cache_dir for cloning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span> <span class="o">=</span> <span class="n">cache_ttl</span>

        <span class="c1"># NO stored state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DataSource|Init] 2-stage pipeline ready | &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;builder=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> | &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;transformer=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Prewarm cache if parameters provided</span>
        <span class="k">if</span> <span class="n">cache_prewarm_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prewarm_cache</span><span class="p">(</span><span class="n">cache_prewarm_params</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_prewarm_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prewarm_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prewarm cache with provided parameter sets.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | CachePrewarm]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: Cache prewarming for faster first access&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;_prewarm_cache&#39;&quot;</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;prewarm_list is list of parameter dictionaries&quot;</span>
<span class="sd">         - post: &quot;Cache populated with Stage 1 (and Stage 2 if transform params present)&quot;</span>
<span class="sd">         - invariant: &quot;Errors are logged but do not stop prewarming process&quot;</span>

<span class="sd">        :complexity: 3</span>

<span class="sd">        Args:</span>
<span class="sd">            prewarm_list: List of parameter dictionaries to prewarm cache with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DataSource|Prewarm] Starting cache prewarm with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">prewarm_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> parameter sets&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">raw_params</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prewarm_list</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_processed_data</span><span class="p">(</span><span class="n">raw_params</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;[DataSource|Prewarm] Prewarmed item #</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">raw_params</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[DataSource|Prewarm] Skipped item #</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[DataSource|Prewarm] Cache prewarm completed&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_cache_key</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">handler</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create cache key for specific pipeline stage.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Caching]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;Stage-specific cache keys INCLUDING handler instance for proper cache isolation&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;_get_cache_key&#39;&quot;</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;stage is valid string, params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns stable cache key unique to stage + params + handler&quot;</span>
<span class="sd">         - invariant: &quot;Different builders/transformers get different cache keys; Same handler + params → same cache key&quot;</span>

<span class="sd">        :decision_cache: &quot;Use get_stable_handler_id for stable handler identification (Contract 3)&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            stage: Pipeline stage (&#39;build&#39;, &#39;transform&#39;)</span>
<span class="sd">            params: Parameters relevant to this stage</span>
<span class="sd">            handler: Optional handler (DataBuilder or DataTransformer) for handler-specific suffix</span>

<span class="sd">        Returns:</span>
<span class="sd">            Stable cache key string including handler identity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get handler-specific suffix if not provided</span>
        <span class="k">if</span> <span class="n">handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;build&quot;</span><span class="p">:</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span>
            <span class="k">elif</span> <span class="n">stage</span> <span class="o">==</span> <span class="s2">&quot;transform&quot;</span><span class="p">:</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span>

        <span class="c1"># Get stable handler ID using hashing utility (Contract 3)</span>
        <span class="n">handler_suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">handler</span><span class="p">:</span>
            <span class="n">handler_suffix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">get_stable_handler_id</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Build cache key</span>
        <span class="c1"># For in-memory cache (cache_dir is None), omit instance_id to allow sharing across instances</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">_default</span><span class="si">{</span><span class="n">handler_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># Normalize params to ensure pandas objects are hashed and complex types are serializable</span>
        <span class="n">normalized_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_params_for_cache</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">params_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">normalized_params</span><span class="p">,</span> <span class="n">sort_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">NumpyEncoder</span><span class="p">)</span>
        <span class="c1"># Include instance_id only when using a persistent cache (disk) to avoid collisions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">:</span>
            <span class="n">instance_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">params_json</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">instance_id</span><span class="si">}{</span><span class="n">handler_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">params_json</span><span class="si">}{</span><span class="n">handler_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_normalize_params_for_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare params for cache key generation by:</span>
<span class="sd">        - Recursively traversing dict/list/tuple/set structures</span>
<span class="sd">        - Replacing pandas objects (DataFrame/Series/Index) with stable content hashes</span>
<span class="sd">        - Leaving other values as-is for JSON serialization via NumpyEncoder</span>

<span class="sd">        Returns a JSON-serializable structure representing the params and any pandas content.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">to_serializable</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">series_hash</span> <span class="o">=</span> <span class="n">hash_pandas_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># Combine into a single deterministic integer</span>
                    <span class="n">combined</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">series_hash</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Fallback: for DataFrame, hash per-column series and combine</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">col_hashes</span> <span class="o">=</span> <span class="p">[]</span>
                            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                                <span class="n">s_hash</span> <span class="o">=</span> <span class="n">hash_pandas_object</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="n">col_hashes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s_hash</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
                            <span class="n">combined</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">col_hashes</span><span class="p">))</span>
                        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                            <span class="n">combined</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">combined</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;__pandas_hash__&quot;</span><span class="p">:</span> <span class="n">combined</span><span class="p">}</span>

            <span class="c1"># Collections</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">to_serializable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">to_serializable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">to_serializable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">])</span>

            <span class="c1"># Default: leave as-is (NumpyEncoder will handle numpy types)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">to_serializable</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get built data from cache or build fresh.</span>

<span class="sd">        Stage 1: Build (load + process).</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Stage1]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns complete built DataFrame&quot;</span>
<span class="sd">         - cache_key: &quot;Based on build params only&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Build parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Complete built DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage1|Build] No params | params=</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cache_key</span><span class="p">(</span><span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Stage1|Build] Cache HIT&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[Stage1|Build] Cache MISS | building&quot;</span><span class="p">)</span>

        <span class="c1"># Call DataBuilder.build() - handles load + process</span>
        <span class="n">built_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DataBuilder.build must return DataFrame, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">built_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">built_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage1|Build] Complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">built_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">built_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">built_data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get filtered data from cache or filter fresh.</span>

<span class="sd">        Stage 2: Filter.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | Stage2]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;built_data is DataFrame, params is dict&quot;</span>
<span class="sd">         - post: &quot;Returns filtered DataFrame&quot;</span>
<span class="sd">         - cache_key: &quot;Based on filter params + built_data content hash&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            built_data: Built DataFrame from stage 1</span>
<span class="sd">            params: Filter parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">built_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">built_data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[Stage2|Transform] No built_data | built_data=</span><span class="si">{</span><span class="n">built_data</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">built_data</span>
        <span class="c1"># Include built_data in cache key via hashed representation without mutating original params</span>
        <span class="n">params_for_key</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">params_for_key</span><span class="p">[</span><span class="s2">&quot;__built_data__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">built_data</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cache_key</span><span class="p">(</span><span class="s2">&quot;transform&quot;</span><span class="p">,</span> <span class="n">params_for_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[Stage2|Filter] Cache HIT&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[Stage2|Transform] Cache MISS | transforming&quot;</span><span class="p">)</span>
        <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DataTransformer.transform must return DataFrame, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">filtered_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Stage2|Transform] Complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered_data</span>

<div class="viewcode-block" id="DataSource.with_builder">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_builder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">builder</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new datasource with replaced builder.</span>

<span class="sd">        Immutable pattern for flexible data pipeline composition.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithBuilder]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;builder is DataBuilder instance&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource (does NOT modify self)&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            builder: DataBuilder instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource with specified builder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="n">builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="n">cache_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_backend</span><span class="p">,</span>  <span class="c1"># Propagate backend for cache sharing</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_builder_fn">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_builder_fn">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_builder_fn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">build_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new datasource instance with a lambda-based builder.</span>

<span class="sd">        Convenience factory for simple build logic without creating DataBuilder class.</span>
<span class="sd">        Symmetric to with_transform_fn() for consistency.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithBuilderFn]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: Symmetric API with with_transform_fn()&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;with_builder_fn&#39;&quot;</span>
<span class="sd">         - uses: [&quot;class: &#39;DataBuilder&#39;&quot;]</span>

<span class="sd">        :rationale: &quot;Lambda-based builder for simple cases, avoiding class boilerplate&quot;</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;build_fn is callable: Dict[str, Any] → DataFrame&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource with lambda builder&quot;</span>
<span class="sd">         - invariant: &quot;Original datasource unchanged (immutable)&quot;</span>

<span class="sd">        :complexity: 2</span>
<span class="sd">        :decision_cache: &quot;Symmetric with_builder_fn/with_transform_fn API for consistency&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            build_fn: Function that builds DataFrame from params.</span>
<span class="sd">                     Signature: lambda params: df</span>
<span class="sd">                     Examples:</span>
<span class="sd">                     - lambda p: pd.read_csv(p[&#39;file_path&#39;])</span>
<span class="sd">                     - lambda p: generate_sample_data(n=p.get(&#39;rows&#39;, 100))</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource instance with lambda builder.</span>
<span class="sd">            Original datasource is unchanged.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Create datasource with lambda builder</span>
<span class="sd">            &gt;&gt;&gt; ds = DataSource().with_builder_fn(</span>
<span class="sd">            ...     lambda params: pd.read_csv(&#39;data.csv&#39;)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Or with params</span>
<span class="sd">            &gt;&gt;&gt; ds = DataSource().with_builder_fn(</span>
<span class="sd">            ...     lambda params: pd.read_csv(params.get(&#39;file&#39;, &#39;default.csv&#39;))</span>
<span class="sd">            ... )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[DataSource|WithBuilderFn] Creating datasource with lambda builder&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Create LambdaBuilder from build_fn (imported from lambda_handlers)</span>
        <span class="n">lambda_builder</span> <span class="o">=</span> <span class="n">LambdaBuilder</span><span class="p">(</span><span class="n">build_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[DataSource|WithBuilderFn] Created lambda builder&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="n">lambda_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="n">cache_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_backend</span><span class="p">,</span>  <span class="c1"># Propagate backend for cache sharing</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_builder</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_transformer">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_transformer">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformer</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new datasource with replaced transformer.</span>

<span class="sd">        Immutable pattern for flexible data pipeline composition.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithTransformer]</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;transformer is DataTransformer instance&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource (does NOT modify self)&quot;</span>

<span class="sd">        :complexity: 2</span>

<span class="sd">        Args:</span>
<span class="sd">            transformer: DataTransformer instance</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource with specified transformer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="n">transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="n">cache_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_backend</span><span class="p">,</span>  <span class="c1"># Propagate backend for cache sharing</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_transformer</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.with_transform_fn">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.with_transform_fn">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">with_transform_fn</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">transform_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DataSource&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new datasource instance with an additional transformation step</span>
<span class="sd">        chained AFTER the main data transformer.</span>

<span class="sd">        Factory method for creating specialized datasources with block-specific</span>
<span class="sd">        transformations. The new transformer is chained after the existing one,</span>
<span class="sd">        preserving the global filter → block transform order.</span>

<span class="sd">        :hierarchy: [Core | DataSources | DataSource | WithTransform]</span>
<span class="sd">        :relates-to:</span>
<span class="sd">         - motivated_by: &quot;v0.15.0: Block-specific data transformations&quot;</span>
<span class="sd">         - implements: &quot;method: &#39;with_transform_fn&#39;&quot;</span>
<span class="sd">         - uses: [&quot;class: &#39;ChainedTransformer&#39;&quot;]</span>

<span class="sd">        :rationale: &quot;Immutable pattern creates specialized clone without modifying original&quot;</span>
<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;transform_fn is callable: DataFrame → DataFrame&quot;</span>
<span class="sd">         - post: &quot;Returns new DataSource with chained transformer&quot;</span>
<span class="sd">         - invariant: &quot;Original datasource unchanged (immutable)&quot;</span>
<span class="sd">         - cache: &quot;New datasource has independent cache keys&quot;</span>

<span class="sd">        :complexity: 4</span>
<span class="sd">        :decision_cache: &quot;Use ChainedTransformer for global filter → block transform pipeline&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            transform_fn: Function that transforms a DataFrame.</span>
<span class="sd">                         Signature: lambda df: df (no params needed)</span>
<span class="sd">                         Examples:</span>
<span class="sd">                         - lambda df: df.groupby(&#39;category&#39;).sum()</span>
<span class="sd">                         - lambda df: df.pivot_table(...)</span>
<span class="sd">                         - lambda df: df.query(&quot;price &gt; 100&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            New DataSource instance with chained transformer.</span>
<span class="sd">            Original datasource is unchanged.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Original datasource with global filter</span>
<span class="sd">            &gt;&gt;&gt; main_ds = DataSource(</span>
<span class="sd">            ...     data_builder=CSVBuilder(&quot;sales.csv&quot;),</span>
<span class="sd">            ...     data_transformer=CategoryFilter()  # Global filter</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create specialized datasource for aggregation</span>
<span class="sd">            &gt;&gt;&gt; agg_ds = main_ds.with_transform_fn(</span>
<span class="sd">            ...     lambda df: df.groupby(&#39;category&#39;)[&#39;sales&#39;].sum().reset_index()</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Original datasource unchanged, agg_ds has chained transformer</span>
<span class="sd">            &gt;&gt;&gt; data = agg_ds.get_processed_data({&#39;category&#39;: &#39;Electronics&#39;})</span>
<span class="sd">            &gt;&gt;&gt; # Flow: Build → CategoryFilter(category=&#39;Electronics&#39;) → GroupBy Aggregation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.data_transformer</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChainedTransformer</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;[DataSource|WithTransform] Creating specialized datasource clone&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 1. Create a new transformer from the provided function (imported from lambda_handlers)</span>
        <span class="n">block_specific_transformer</span> <span class="o">=</span> <span class="n">LambdaTransformer</span><span class="p">(</span><span class="n">transform_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="c1"># 2. Chain it with the existing global transformer</span>
        <span class="n">chained_transformer</span> <span class="o">=</span> <span class="n">ChainedTransformer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">,</span>  <span class="c1"># Global filter (first)</span>
            <span class="n">block_specific_transformer</span><span class="p">,</span>  <span class="c1"># Block transform (second)</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[DataSource|WithTransform] Chained: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> → LambdaTransformer&quot;</span>
        <span class="p">)</span>

        <span class="c1"># 3. Return a new datasource instance (clone) with the new chained transformer</span>
        <span class="c1"># Use stored cache_dir to ensure cache registry key matches parent</span>
        <span class="k">return</span> <span class="n">DataSource</span><span class="p">(</span>
            <span class="n">data_builder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span>
            <span class="n">data_transformer</span><span class="o">=</span><span class="n">chained_transformer</span><span class="p">,</span>
            <span class="n">param_classifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">,</span>
            <span class="n">cache_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_dir</span><span class="p">,</span>
            <span class="n">cache_ttl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">,</span>
            <span class="n">cache_backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_backend</span><span class="p">,</span>  <span class="c1"># Propagate backend for cache sharing</span>
            <span class="c1"># Explicitly pass None for lambda functions since we&#39;re setting data_transformer</span>
            <span class="n">build_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">transform_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DataSource.get_processed_data">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.get_processed_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_processed_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run 2-stage pipeline and return filtered data.</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;params is dict or None&quot;</span>
<span class="sd">         - post: &quot;Returns filtered DataFrame&quot;</span>
<span class="sd">         - stages: &quot;Build → Filter (2 stages)&quot;</span>
<span class="sd">         - invariant: &quot;Stateless (no stored data)&quot;</span>

<span class="sd">        :complexity: 6</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Parameters for build + filter</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered DataFrame from 2-stage pipeline</span>

<span class="sd">        Raises:</span>
<span class="sd">            DataLoadError: If data loading/building fails</span>
<span class="sd">            CacheError: If cache operations fail (warning only, retries without cache)</span>
<span class="sd">            AsyncSyncMismatchError: If async build_fn used with sync method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="c1"># Check for async/sync mismatch</span>
        <span class="c1"># For LambdaBuilder, check the underlying func attribute</span>
        <span class="n">is_async_build</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">):</span>
            <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_async_build</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AsyncSyncMismatchError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot call get_processed_data() with async build_fn. &quot;</span>
                <span class="s2">&quot;Use await get_processed_data_async() instead.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[get_processed_data] Called | params=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Classify params</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.processing_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataProcessingContext</span>

            <span class="n">context</span> <span class="o">=</span> <span class="n">DataProcessingContext</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">)</span>

            <span class="c1"># Stage 1: Build (load + process)</span>
            <span class="n">built_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_build</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span><span class="p">)</span>

            <span class="c1"># Stage 2: Filter</span>
            <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_transform</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">filtering_params</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[get_processed_data] Pipeline complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">except</span> <span class="n">CacheError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[get_processed_data] Cache error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Retry without cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[get_processed_data] Retrying without cache&quot;</span><span class="p">)</span>
            <span class="n">built_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span><span class="p">)</span>
            <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="n">built_data</span><span class="p">,</span> <span class="o">**</span><span class="n">context</span><span class="o">.</span><span class="n">filtering_params</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">except</span> <span class="n">DataLoadError</span><span class="p">:</span>
            <span class="c1"># Re-raise with context</span>
            <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Wrap unexpected errors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[get_processed_data] Unexpected error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data processing failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span></div>


<div class="viewcode-block" id="DataSource.get_processed_data_async">
<a class="viewcode-back" href="../../../api/core.html#dashboard_lego.core.datasource.DataSource.get_processed_data_async">[docs]</a>
    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">get_processed_data_async</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Async version of get_processed_data for use with async frameworks.</span>

<span class="sd">        Supports both async and sync build_fn:</span>
<span class="sd">        - If build_fn is async (coroutine), awaits it directly</span>
<span class="sd">        - If build_fn is sync, runs it in executor to avoid blocking event loop</span>

<span class="sd">        :contract:</span>
<span class="sd">         - pre: &quot;params is dict or None&quot;</span>
<span class="sd">         - post: &quot;Returns filtered DataFrame (async)&quot;</span>
<span class="sd">         - stages: &quot;Build (async-aware) → Filter (sync for now)&quot;</span>
<span class="sd">         - invariant: &quot;Stateless (no stored data)&quot;</span>

<span class="sd">        :complexity: 7</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Parameters for build + filter</span>

<span class="sd">        Returns:</span>
<span class="sd">            Filtered DataFrame from 2-stage pipeline</span>

<span class="sd">        Raises:</span>
<span class="sd">            DataLoadError: If data loading/building fails</span>
<span class="sd">            CacheError: If cache operations fail (warning only, retries without cache)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; async def fetch_api_data(params):</span>
<span class="sd">            ...     async with httpx.AsyncClient() as client:</span>
<span class="sd">            ...         response = await client.get(&#39;/api/data&#39;)</span>
<span class="sd">            ...     return pd.DataFrame(response.json())</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; ds = DataSource(build_fn=fetch_api_data)</span>
<span class="sd">            &gt;&gt;&gt; df = await ds.get_processed_data_async({&#39;limit&#39;: 100})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[get_processed_data_async] Called | params=</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Classify params</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">dashboard_lego.core.processing_context</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataProcessingContext</span>

            <span class="n">context</span> <span class="o">=</span> <span class="n">DataProcessingContext</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_classifier</span><span class="p">)</span>

            <span class="c1"># Stage 1: Build (async-aware)</span>
            <span class="n">built_data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_build_async</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span><span class="p">)</span>

            <span class="c1"># Stage 2: Filter (sync for now, per implementation plan)</span>
            <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_transform</span><span class="p">(</span><span class="n">built_data</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">filtering_params</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[get_processed_data_async] Pipeline complete | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">filtered_data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">except</span> <span class="n">CacheError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[get_processed_data_async] Cache error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Retry without cache</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;[get_processed_data_async] Retrying without cache&quot;</span><span class="p">)</span>

            <span class="c1"># Detect if build function is async</span>
            <span class="n">is_async_build</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">):</span>
                <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">)</span>

            <span class="c1"># Check if build is async</span>
            <span class="k">if</span> <span class="n">is_async_build</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">):</span>
                    <span class="c1"># LambdaBuilder: call func directly</span>
                    <span class="n">built_data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                        <span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Regular async DataBuilder</span>
                    <span class="n">built_data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
                        <span class="o">**</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Run sync build in executor</span>
                <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">_sync_build_wrapper</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">context</span><span class="o">.</span><span class="n">preprocessing_params</span><span class="p">)</span>

                <span class="n">built_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_sync_build_wrapper</span><span class="p">)</span>

            <span class="n">filtered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="n">built_data</span><span class="p">,</span> <span class="o">**</span><span class="n">context</span><span class="o">.</span><span class="n">filtering_params</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">filtered_data</span>

        <span class="k">except</span> <span class="n">DataLoadError</span><span class="p">:</span>
            <span class="c1"># Re-raise with context</span>
            <span class="k">raise</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Wrap unexpected errors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[get_processed_data_async] Unexpected error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">DataLoadError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Async data processing failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span></div>


    <span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_build_async</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Async version of _get_or_build.</span>

<span class="sd">        Checks cache first, then builds data using async-aware logic:</span>
<span class="sd">        - If build_fn is async coroutine, awaits it</span>
<span class="sd">        - If build_fn is sync, runs in executor to avoid blocking</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Build parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            Built DataFrame (from cache or fresh build)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cache_key</span><span class="p">(</span><span class="s2">&quot;build&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">)</span>

        <span class="c1"># Try cache first</span>
        <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[_get_or_build_async] Cache HIT | key=</span><span class="si">{</span><span class="n">cache_key</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[_get_or_build_async] Cache MISS | key=</span><span class="si">{</span><span class="n">cache_key</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Detect if build function is async</span>
        <span class="c1"># For LambdaBuilder, check the underlying func attribute</span>
        <span class="n">is_async_build</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">):</span>
            <span class="c1"># LambdaBuilder case - check the wrapped function</span>
            <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regular DataBuilder case - check the build method</span>
            <span class="n">is_async_build</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">)</span>

        <span class="c1"># Build data (async-aware)</span>
        <span class="k">if</span> <span class="n">is_async_build</span><span class="p">:</span>
            <span class="c1"># Async build_fn - call directly and await</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[_get_or_build_async] Using async build_fn&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">):</span>
                <span class="c1"># LambdaBuilder: call func directly</span>
                <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Regular async DataBuilder</span>
                <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sync build_fn - run in executor</span>
            <span class="c1"># Need to wrap the call to unpack params as kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;[_get_or_build_async] Using sync build_fn in executor&quot;</span><span class="p">)</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_sync_build_wrapper</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_builder</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">loop</span><span class="o">.</span><span class="n">run_in_executor</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">_sync_build_wrapper</span><span class="p">)</span>

        <span class="c1"># Cache result</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cache_key</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">expire</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_ttl</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;[_get_or_build_async] Cached | key=</span><span class="si">{</span><span class="n">cache_key</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span><span class="si">}</span><span class="s2"> | rows=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[_get_or_build_async] Cache write failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Continue without caching</span>

        <span class="k">return</span> <span class="n">data</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Dashboard Lego Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>